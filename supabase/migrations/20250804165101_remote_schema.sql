create type "public"."displaystyletype" as enum ('First', 'First-LastInitial', 'FirstInitial-Last', 'FirstLast');

create type "public"."stripnumberingtype" as enum ('Pods', 'SequentialNumbers');

drop policy "Users can manage their own device tokens" on "public"."device_tokens";

alter table "public"."action" drop constraint "action_symptomclass_fkey";

alter table "public"."device_tokens" drop constraint "device_tokens_platform_check";

alter table "public"."symptomclass" drop constraint "symptomclass_crewtype_fkey";

alter table "public"."device_tokens" drop constraint "device_tokens_user_id_fkey";

drop function if exists "public"."search_users"(first_name_pattern text, last_name_pattern text);

alter table "public"."crews" drop constraint "crews_pkey";

alter table "public"."events" drop constraint "events_pkey";

drop index if exists "public"."crews_pkey";

drop index if exists "public"."events_pkey";

create table "public"."notification_preferences" (
    "user_id" text not null,
    "new_problems" boolean default true,
    "responses" boolean default true,
    "resolutions" boolean default true,
    "messages" boolean default true
);


alter table "public"."notification_preferences" enable row level security;

create table "public"."pending_users" (
    "email" text not null,
    "firstname" text not null,
    "lastname" text not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "phone_number" text not null
);


alter table "public"."pending_users" enable row level security;

create table "public"."responders" (
    "id" bigint generated always as identity not null,
    "problem" bigint not null,
    "user_id" text not null,
    "responded_at" timestamp with time zone default now()
);


alter table "public"."responders" enable row level security;

alter table "public"."action" drop column "symptomclass";

alter table "public"."action" add column "symptom" bigint;

alter table "public"."crews" alter column "display_style" set data type displaystyletype using "display_style"::displaystyletype;

alter table "public"."device_tokens" drop column "updated_at";

alter table "public"."device_tokens" alter column "id" drop default;

alter table "public"."device_tokens" alter column "id" add generated always as identity;

alter table "public"."device_tokens" alter column "id" set data type bigint using "id"::bigint;

alter table "public"."device_tokens" alter column "user_id" set data type text using "user_id"::text;

alter table "public"."events" alter column "stripnumbering" set data type stripnumberingtype using "stripnumbering"::stripnumberingtype;

alter table "public"."messages" add column "include_reporter" boolean default false;

alter table "public"."messages" add column "problem" bigint;

alter table "public"."messages" alter column "id" set generated by default;

alter table "public"."problem" add column "notes" text;

alter table "public"."symptomclass" drop column "crewtype";

alter table "public"."symptomclass" add column "crewType" bigint;

CREATE UNIQUE INDEX crew_pkey ON public.crews USING btree (id);

CREATE UNIQUE INDEX event_pkey ON public.events USING btree (id);

CREATE INDEX idx_notification_preferences_user_id ON public.notification_preferences USING btree (user_id);

CREATE INDEX idx_responders_problem ON public.responders USING btree (problem);

CREATE INDEX idx_responders_user_id ON public.responders USING btree (user_id);

CREATE UNIQUE INDEX notification_preferences_pkey ON public.notification_preferences USING btree (user_id);

CREATE UNIQUE INDEX pending_users_pkey ON public.pending_users USING btree (email);

CREATE UNIQUE INDEX responders_pkey ON public.responders USING btree (id);

CREATE UNIQUE INDEX responders_problem_user_id_key ON public.responders USING btree (problem, user_id);

alter table "public"."crews" add constraint "crew_pkey" PRIMARY KEY using index "crew_pkey";

alter table "public"."events" add constraint "event_pkey" PRIMARY KEY using index "event_pkey";

alter table "public"."notification_preferences" add constraint "notification_preferences_pkey" PRIMARY KEY using index "notification_preferences_pkey";

alter table "public"."pending_users" add constraint "pending_users_pkey" PRIMARY KEY using index "pending_users_pkey";

alter table "public"."responders" add constraint "responders_pkey" PRIMARY KEY using index "responders_pkey";

alter table "public"."action" add constraint "action_symptom_fkey" FOREIGN KEY (symptom) REFERENCES symptom(id) not valid;

alter table "public"."action" validate constraint "action_symptom_fkey";

alter table "public"."crewmembers" add constraint "crewmembers_crewmember_fkey1" FOREIGN KEY (crewmember) REFERENCES users(supabase_id) not valid;

alter table "public"."crewmembers" validate constraint "crewmembers_crewmember_fkey1";

alter table "public"."messages" add constraint "fk_messages_problem" FOREIGN KEY (problem) REFERENCES problem(id) ON DELETE CASCADE not valid;

alter table "public"."messages" validate constraint "fk_messages_problem";

alter table "public"."notification_preferences" add constraint "notification_preferences_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(supabase_id) not valid;

alter table "public"."notification_preferences" validate constraint "notification_preferences_user_id_fkey";

alter table "public"."responders" add constraint "responders_problem_fkey" FOREIGN KEY (problem) REFERENCES problem(id) not valid;

alter table "public"."responders" validate constraint "responders_problem_fkey";

alter table "public"."responders" add constraint "responders_problem_user_id_key" UNIQUE using index "responders_problem_user_id_key";

alter table "public"."responders" add constraint "responders_user_fkey" FOREIGN KEY (user_id) REFERENCES users(supabase_id) not valid;

alter table "public"."responders" validate constraint "responders_user_fkey";

alter table "public"."symptomclass" add constraint "symptomclass_crewType_fkey" FOREIGN KEY ("crewType") REFERENCES crewtypes(id) not valid;

alter table "public"."symptomclass" validate constraint "symptomclass_crewType_fkey";

alter table "public"."device_tokens" add constraint "device_tokens_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(supabase_id) not valid;

alter table "public"."device_tokens" validate constraint "device_tokens_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_new_messages(since_time timestamp with time zone, problem_ids text)
 RETURNS SETOF messages
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT *
  FROM messages
  WHERE created_at > since_time
    AND problem::text = ANY(string_to_array(problem_ids, ','))
  ORDER BY created_at ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_new_problems(event_id integer, since_time timestamp with time zone, crew_filter text)
 RETURNS SETOF problem
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  EXECUTE format('
    SELECT p.*,
           s.symptomstring,
           a.actionstring,
           m.*
    FROM problem p
    LEFT JOIN symptom s ON p.symptom = s.id
    LEFT JOIN action a ON p.action = a.id
    LEFT JOIN LATERAL (
      SELECT json_agg(m.*) as messages
      FROM messages m
      WHERE m.problem = p.id
    ) m ON true
    WHERE p.event = %L
      AND p.startdatetime > %L
      %s
    ORDER BY p.startdatetime DESC',
    event_id, since_time, crew_filter);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_new_problems(event_id integer, since_time timestamp with time zone, crew_id integer, user_id text)
 RETURNS SETOF problem
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT *
    FROM problem
    WHERE problem.event = event_id
      AND (crew_id IS NULL OR problem.crew = crew_id)
      AND problem.startdatetime > since_time;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_new_problems(event_id text, since_time timestamp with time zone, crew_filter text)
 RETURNS SETOF problem
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  EXECUTE format('
    SELECT p.*,
           s.symptomstring,
           a.actionstring,
           m.*
    FROM problem p
    LEFT JOIN symptom s ON p.symptom = s.id
    LEFT JOIN action a ON p.action = a.id
    LEFT JOIN LATERAL (
      SELECT json_agg(m.*) as messages
      FROM messages m
      WHERE m.problem = p.id
    ) m ON true
    WHERE p.event = %L
      AND p.startdatetime > %L
      %s
    ORDER BY p.startdatetime DESC',
    event_id::int, since_time, crew_filter);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_new_problems_no_crew(event_id text, since_time timestamp with time zone, user_id text)
 RETURNS SETOF problem
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT *
    FROM problem
    WHERE event_id = event_id
      AND created_at > since_time;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_new_problems_wrapper(event_id integer, since_time timestamp with time zone, crew_id integer DEFAULT NULL::integer, user_id text DEFAULT NULL::text)
 RETURNS SETOF problem
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Validate required parameters
    IF event_id IS NULL OR since_time IS NULL OR user_id IS NULL THEN
        RAISE EXCEPTION 'event_id, since_time, and user_id are required parameters';
    END IF;

    RETURN QUERY
    SELECT * FROM get_new_problems(
        event_id,
        since_time,
        crew_id,
        user_id
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_resolved_problems(event_id bigint, crew_id bigint, since_time timestamp with time zone)
 RETURNS TABLE(id bigint, enddatetime timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT p.id, p.enddatetime
  FROM problem p
  WHERE p.event = event_id
    AND p.crew = crew_id
    AND p.enddatetime > since_time;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_crew_chief(user_id uuid, crew_id bigint)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM crews
    WHERE id = crew_id AND crew_chief = user_id::text
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_organizer(user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM users
    WHERE supabase_id = user_id::text AND organizer = true
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_superuser(user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM users
    WHERE supabase_id = user_id::text AND superuser = true
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_users(first_name_pattern text, last_name_pattern text)
 RETURNS TABLE(id text, firstname text, lastname text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT u.supabase_id AS id, u.firstname, u.lastname
    FROM users u
    WHERE
        (u.firstname ILIKE first_name_pattern OR u.lastname ILIKE last_name_pattern)
    ORDER BY u.firstname ASC
    LIMIT 10;
END;
$function$
;

grant delete on table "public"."notification_preferences" to "anon";

grant insert on table "public"."notification_preferences" to "anon";

grant references on table "public"."notification_preferences" to "anon";

grant select on table "public"."notification_preferences" to "anon";

grant trigger on table "public"."notification_preferences" to "anon";

grant truncate on table "public"."notification_preferences" to "anon";

grant update on table "public"."notification_preferences" to "anon";

grant delete on table "public"."notification_preferences" to "authenticated";

grant insert on table "public"."notification_preferences" to "authenticated";

grant references on table "public"."notification_preferences" to "authenticated";

grant select on table "public"."notification_preferences" to "authenticated";

grant trigger on table "public"."notification_preferences" to "authenticated";

grant truncate on table "public"."notification_preferences" to "authenticated";

grant update on table "public"."notification_preferences" to "authenticated";

grant delete on table "public"."notification_preferences" to "service_role";

grant insert on table "public"."notification_preferences" to "service_role";

grant references on table "public"."notification_preferences" to "service_role";

grant select on table "public"."notification_preferences" to "service_role";

grant trigger on table "public"."notification_preferences" to "service_role";

grant truncate on table "public"."notification_preferences" to "service_role";

grant update on table "public"."notification_preferences" to "service_role";

grant delete on table "public"."pending_users" to "anon";

grant insert on table "public"."pending_users" to "anon";

grant references on table "public"."pending_users" to "anon";

grant select on table "public"."pending_users" to "anon";

grant trigger on table "public"."pending_users" to "anon";

grant truncate on table "public"."pending_users" to "anon";

grant update on table "public"."pending_users" to "anon";

grant delete on table "public"."pending_users" to "authenticated";

grant insert on table "public"."pending_users" to "authenticated";

grant references on table "public"."pending_users" to "authenticated";

grant select on table "public"."pending_users" to "authenticated";

grant trigger on table "public"."pending_users" to "authenticated";

grant truncate on table "public"."pending_users" to "authenticated";

grant update on table "public"."pending_users" to "authenticated";

grant delete on table "public"."pending_users" to "service_role";

grant insert on table "public"."pending_users" to "service_role";

grant references on table "public"."pending_users" to "service_role";

grant select on table "public"."pending_users" to "service_role";

grant trigger on table "public"."pending_users" to "service_role";

grant truncate on table "public"."pending_users" to "service_role";

grant update on table "public"."pending_users" to "service_role";

grant delete on table "public"."responders" to "anon";

grant insert on table "public"."responders" to "anon";

grant references on table "public"."responders" to "anon";

grant select on table "public"."responders" to "anon";

grant trigger on table "public"."responders" to "anon";

grant truncate on table "public"."responders" to "anon";

grant update on table "public"."responders" to "anon";

grant delete on table "public"."responders" to "authenticated";

grant insert on table "public"."responders" to "authenticated";

grant references on table "public"."responders" to "authenticated";

grant select on table "public"."responders" to "authenticated";

grant trigger on table "public"."responders" to "authenticated";

grant truncate on table "public"."responders" to "authenticated";

grant update on table "public"."responders" to "authenticated";

grant delete on table "public"."responders" to "service_role";

grant insert on table "public"."responders" to "service_role";

grant references on table "public"."responders" to "service_role";

grant select on table "public"."responders" to "service_role";

grant trigger on table "public"."responders" to "service_role";

grant truncate on table "public"."responders" to "service_role";

grant update on table "public"."responders" to "service_role";

create policy "action_read_policy"
on "public"."action"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "action_write_policy"
on "public"."action"
as permissive
for all
to public
using (is_superuser(auth.uid()));


create policy "crewmembers_create_policy"
on "public"."crewmembers"
as permissive
for insert
to public
with check ((is_superuser(auth.uid()) OR is_crew_chief(auth.uid(), crew)));


create policy "crewmembers_delete_policy"
on "public"."crewmembers"
as permissive
for delete
to public
using ((is_superuser(auth.uid()) OR is_crew_chief(auth.uid(), crew)));


create policy "crewmembers_read_policy"
on "public"."crewmembers"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND (is_superuser(auth.uid()) OR is_crew_chief(auth.uid(), crew) OR (crewmember = (auth.uid())::text))));


create policy "crewmembers_update_policy"
on "public"."crewmembers"
as permissive
for update
to public
using ((is_superuser(auth.uid()) OR is_crew_chief(auth.uid(), crew)));


create policy "crews_create_policy"
on "public"."crews"
as permissive
for insert
to public
with check ((is_superuser(auth.uid()) OR is_organizer(auth.uid())));


create policy "crews_delete_policy"
on "public"."crews"
as permissive
for delete
to public
using ((is_superuser(auth.uid()) OR (is_organizer(auth.uid()) AND (crew_chief = (auth.uid())::text))));


create policy "crews_read_policy"
on "public"."crews"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "crews_update_policy"
on "public"."crews"
as permissive
for update
to public
using ((is_superuser(auth.uid()) OR (is_organizer(auth.uid()) AND (crew_chief = (auth.uid())::text))));


create policy "crewtypes_read_policy"
on "public"."crewtypes"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "crewtypes_write_policy"
on "public"."crewtypes"
as permissive
for all
to public
using (is_superuser(auth.uid()));


create policy "device_tokens_policy"
on "public"."device_tokens"
as permissive
for all
to public
using ((user_id = (auth.uid())::text));


create policy "events_create_policy"
on "public"."events"
as permissive
for insert
to public
with check ((is_superuser(auth.uid()) OR is_organizer(auth.uid())));


create policy "events_delete_policy"
on "public"."events"
as permissive
for delete
to public
using ((is_superuser(auth.uid()) OR (is_organizer(auth.uid()) AND (organizer = (auth.uid())::text))));


create policy "events_read_policy"
on "public"."events"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "events_update_policy"
on "public"."events"
as permissive
for update
to public
using ((is_superuser(auth.uid()) OR (is_organizer(auth.uid()) AND (organizer = (auth.uid())::text))));


create policy "messages_create_policy"
on "public"."messages"
as permissive
for insert
to public
with check (((auth.role() = 'authenticated'::text) AND (is_superuser(auth.uid()) OR (EXISTS ( SELECT 1
   FROM crewmembers cm
  WHERE ((cm.crew = messages.crew) AND (cm.crewmember = (auth.uid())::text)))))));


create policy "messages_read_policy"
on "public"."messages"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND (is_superuser(auth.uid()) OR (EXISTS ( SELECT 1
   FROM crewmembers cm
  WHERE ((cm.crew = messages.crew) AND (cm.crewmember = (auth.uid())::text)))))));


create policy "notification_preferences_policy"
on "public"."notification_preferences"
as permissive
for all
to public
using ((user_id = (auth.uid())::text));


create policy "oldproblemsymptom_read_policy"
on "public"."oldproblemsymptom"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND (is_superuser(auth.uid()) OR (EXISTS ( SELECT 1
   FROM (problem p
     JOIN crewmembers cm ON ((p.crew = cm.crew)))
  WHERE ((p.id = oldproblemsymptom.problem) AND (cm.crewmember = (auth.uid())::text)))))));


create policy "oldproblemsymptom_write_policy"
on "public"."oldproblemsymptom"
as permissive
for all
to public
using (is_superuser(auth.uid()));


create policy "PendingUsersDeletePolicy"
on "public"."pending_users"
as permissive
for delete
to public
using ((auth.role() = 'authenticated'::text));


create policy "PendingUsersInsertPolicy"
on "public"."pending_users"
as permissive
for insert
to public
with check (true);


create policy "PendingUsersReadPolicy"
on "public"."pending_users"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "problem_create_policy"
on "public"."problem"
as permissive
for insert
to public
with check ((is_superuser(auth.uid()) OR (EXISTS ( SELECT 1
   FROM crewmembers cm
  WHERE ((cm.crew = problem.crew) AND (cm.crewmember = (auth.uid())::text))))));


create policy "problem_delete_policy"
on "public"."problem"
as permissive
for delete
to public
using ((is_superuser(auth.uid()) OR is_crew_chief(auth.uid(), crew)));


create policy "problem_read_policy"
on "public"."problem"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND (is_superuser(auth.uid()) OR (EXISTS ( SELECT 1
   FROM crewmembers cm
  WHERE ((cm.crew = problem.crew) AND (cm.crewmember = (auth.uid())::text)))))));


create policy "problem_update_policy"
on "public"."problem"
as permissive
for update
to public
using ((is_superuser(auth.uid()) OR is_crew_chief(auth.uid(), crew) OR (originator = (auth.uid())::text)));


create policy "responders_create_policy"
on "public"."responders"
as permissive
for insert
to public
with check (((auth.role() = 'authenticated'::text) AND (is_superuser(auth.uid()) OR ((user_id = (auth.uid())::text) AND (EXISTS ( SELECT 1
   FROM (problem p
     JOIN crewmembers cm ON ((p.crew = cm.crew)))
  WHERE ((p.id = responders.problem) AND (cm.crewmember = (auth.uid())::text)))))));


create policy "responders_read_policy"
on "public"."responders"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND (is_superuser(auth.uid()) OR (user_id = (auth.uid())::text) OR (EXISTS ( SELECT 1
   FROM (problem p
     JOIN crewmembers cm ON ((p.crew = cm.crew)))
  WHERE ((p.id = responders.problem) AND (cm.crewmember = (auth.uid())::text)))))));


create policy "symptom_read_policy"
on "public"."symptom"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "symptom_write_policy"
on "public"."symptom"
as permissive
for all
to public
using (is_superuser(auth.uid()));


create policy "symptomclass_read_policy"
on "public"."symptomclass"
as permissive
for select
to public
using ((auth.role() = 'authenticated'::text));


create policy "symptomclass_write_policy"
on "public"."symptomclass"
as permissive
for all
to public
using (is_superuser(auth.uid()));


create policy "users_create_policy"
on "public"."users"
as permissive
for insert
to public
with check ((is_superuser(auth.uid()) OR (supabase_id = (auth.uid())::text)));


create policy "users_delete_policy"
on "public"."users"
as permissive
for delete
to public
using (is_superuser(auth.uid()));


create policy "users_read_policy"
on "public"."users"
as permissive
for select
to public
using (((auth.role() = 'authenticated'::text) AND (is_superuser(auth.uid()) OR (supabase_id = (auth.uid())::text))));


create policy "users_update_policy"
on "public"."users"
as permissive
for update
to public
using ((is_superuser(auth.uid()) OR (supabase_id = (auth.uid())::text)));
